# swtcnode.default.conf  
#

lua_package_path "${prefix}/../lib/?.lua;;";
upstream swtc_ws_server {
    include /etc/nginx/conf.d/ws_servers; 
}
upstream swtc_wss_server {
    include /etc/nginx/conf.d/wss_servers;
}
lua_shared_dict healthcheck 1m;

lua_socket_log_errors off;

init_by_lua_block {
    local process = require "ngx.process"

    local ok, err = process.enable_privileged_agent()
    if not ok then
        ngx.log(ngx.ERR, "enables privileged agent failed error:", err)
    end
}

resolver 223.5.5.5;
# lua_max_running_timers 3;
# lua_max_pending_timers 3;

init_worker_by_lua_block {
    local hc = require "resty.upstream.healthcheck"

    -- raw websocket command , white words ,black words for checking
    local ws_cmd_checks = {}
    ws_cmd_checks[1] = {[[{"id": 1,"command":"server_info"}]], "(full|proposing)", "Insufficient"}
    ws_cmd_checks[2] = {[[{"id":2,"command":"account_info","account":"j4BdJBUCQN8JETufzagGZyqwxmTwJL42Vg"}]], nil, "Insufficient"}
    ws_cmd_checks[3] = {[[{"id":3,"command":"account_lines","account":"j4BdJBUCQN8JETufzagGZyqwxmTwJL42Vg"}]], nil, "Insufficient"}

    local ok, err = hc.spawn_checker{
        shm = "healthcheck",  -- defined by "lua_shared_dict"
        upstream = "swtc_ws_server", -- defined by "upstream"
        type = "ws",
        ws_cmd_checks = ws_cmd_checks,
        interval = 3000,  -- run the check cycle every 3 sec
        timeout = 4000,   -- 4 sec is the timeout for network operations
        fall = 2,  -- # of successive failures before turning a peer down
        rise = 5,  -- # of successive successes before turning a peer up
        concurrency = 10,  -- concurrency level for test requests
    }
    if not ok then
        ngx.log(ngx.ERR, "failed to spawn health checker: ", err)
        return
    end

    local ok, err = hc.spawn_checker{
        shm = "healthcheck",  -- defined by "lua_shared_dict"
        upstream = "swtc_wss_server", -- defined by "upstream"
        type = "wss",
        ws_cmd_checks = ws_cmd_checks,
        interval = 3000,  -- run the check cycle every 3 sec
        timeout = 4000,   -- 4 sec is the timeout for network operations
        fall = 2,  -- # of successive failures before turning a peer down
        rise = 5,  -- # of successive successes before turning a peer up
        concurrency = 10,  -- concurrency level for test requests
    }
    if not ok then
        ngx.log(ngx.ERR, "failed to spawn health checker: ", err)
        return
    end
    
    -- # update the server list
    local function reset_server_list(premature)
        local cjson = require "cjson"
        local http = require "resty.http"
        local httpc = http.new()

        local zabbix_rpc_addr = "https://stats.swtc.top/zabbix/api_jsonrpc.php"
        local params = {
            method = "POST",
            body = [[{"jsonrpc":"2.0","method":"user.login","params":{"user":"swtcnode","password":"swtcnode@2019"},"id":1}]],
            headers = {
                ["Content-Type"] = "application/json-rpc",
            },
            ssl_verify = false,
        }

        -- # login zabbix server and get authid
        params["body"] = [[{"jsonrpc":"2.0","method":"user.login","params":{"user":"swtcnode","password":"swtcnode@2019"},"id":1}]]
        local res, err = httpc:request_uri(zabbix_rpc_addr, params)
        if not res then
            ngx.log(ngx.ERR, "failed to request: " .. err)
            return
        end
        local authid = cjson.decode(res.body).result
        if not authid then
            ngx.log(ngx.ERR, "failed to login zabbix server with given user and password. ")
            return
        end

        -- # get zabbix host group [Skywelld/Discovered Node] 's id
        params["body"] = [=[{"jsonrpc":"2.0","method":"hostgroup.get","params":{"output":"groupid","filter":{"name":["Skywelld/Discovered Node"]}},"auth":"]=]
                .. authid .. [=[","id":2}]=]
        res, err = httpc:request_uri(zabbix_rpc_addr, params)                    
        if not res then
            ngx.log(ngx.ERR, "failed to request: " .. err)
            return
        end
        local gid = cjson.decode(res.body).result[1].groupid
        if not gid then
            ngx.log(ngx.ERR, "failed to get group id of Skywelld/Discovered Node. ")
            return
        end

        -- # get zabbix discoverd p2p net's server list
        params["body"] = [=[{"jsonrpc":"2.0","method":"host.get","params":{"output":["host"],"groupids":["]=] 
                .. gid .. [=["],"sortfield":"host"},"auth":"]=]
                .. authid .. [=[","id":3}]=]
        res, err = httpc:request_uri(zabbix_rpc_addr, params)                    
        if not res then
            ngx.log(ngx.ERR, "failed to request: " .. err)
            return
        end
        local servers = cjson.decode(res.body).result
        if not servers then
            ngx.log(ngx.ERR, "failed to get skywelld's p2p peers from zabbix system.")
            return
        end

        -- # write zabbix discoverd servers to nginx's conf file
        local f, err = io.open("/etc/nginx/conf.d/ws_servers", "w+")
        if not f then
            ngx.log(ngx.ERR, "failed to open ws_servers file.")
            return
        end
        for _, server in pairs(servers) do
            f:write("    server  " .. server.host .. ":5020;\n") 
        end
        f:close ()
        restart_nginx()
    end

    -- reload the nginx by shell command
    local function restart_nginx()
        local shell = require "resty.shell"
        f, err = io.open(ngx.config.prefix() .. "/logs/nginx.pid", "r")
        if not f then
            ngx.log(ngx.ERR, "failed to open nginx pid file.")
            return
        end
        local pid = f:read()
        f:close()
        local ok, stdout, stderr, reason, status =
            shell.run("kill -HUP " .. pid)
        if not ok then
            ngx.log(ngx.ERR, "failed to reload nginx by signal HUP.")
            return
        end
    end

    -- # update the server list
    local function reget_ssl_certificate(premature)
        -- # reload the nginx by shell command
        local shell = require "resty.shell"
        local ok, stdout, stderr, reason, status =
            shell.run("wget -O /etc/nginx/conf.d/fullchain.pem https://jccdex.cn/cert/fullchain.pem;" .. 
                        "wget -O /etc/nginx/conf.d/privkey.pem https://jccdex.cn/cert/privkey.pem ")
        if not ok then
            ngx.log(ngx.ERR, "failed to reload nginx by signal HUP.")
            return
        end
        restart_nginx()
    end

    local process = require "ngx.process"
    if process.type() == "privileged agent" then
        local ok, err = ngx.timer.every(3600, reset_server_list)
        if not ok then
            ngx.log(ngx.ERR, "failed to create the timer: ", err)
        end
        ok, err = ngx.timer.at(0, reget_ssl_certificate)
        if not ok then
            ngx.log(ngx.ERR, "failed to create the timer: ", err)
        end
        ok, err = ngx.timer.every(60, function() ngx.log(ngx.ERR, "pending_count(timer):" .. ngx.timer.pending_count()) end)
        if not ok then
            ngx.log(ngx.ERR, "failed to create the timer: ", err)
        end
        ok, err = ngx.timer.every(24*3600, reget_ssl_certificate)
        if not ok then
            ngx.log(ngx.ERR, "failed to create the timer: ", err)
        end
    end

}
server {
    listen 5028 ssl;

    ssl_certificate /etc/nginx/conf.d/fullchain.pem;
    ssl_certificate_key /etc/nginx/conf.d/privkey.pem;

    ssl_session_timeout 5m;

    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers "HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES";
    ssl_prefer_server_ciphers on;

    ssl_certificate_by_lua_block {
        local ssl = require "ngx.ssl"
        local ok, err = ssl.server_name()
        if not ok then
            ngx.log(ngx.ERR, "failed to get server name from client req.")
        end
        ngx.log(ngx.ERR, "scheme is : xxx")
   }

    location / {
        proxy_pass  https://swtc_wss_server;
        proxy_ssl_verify off;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    
        proxy_connect_timeout       60s;
        proxy_read_timeout          60s;
        proxy_send_timeout          60s;
    }
}
server {
    listen 5020;

    location / {
        proxy_pass  http://swtc_ws_server;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    
        proxy_connect_timeout       60s;
        proxy_read_timeout          60s;
        proxy_send_timeout          60s;
    }
    # status page for all the peers:
    location = /status {
        access_log off;
        allow 127.0.0.1;
        allow 172.17.0.1;
        deny all;
    
        default_type text/plain;
        content_by_lua_block {
            local hc = require "resty.upstream.healthcheck"
            ngx.say("Nginx Worker PID: ", ngx.worker.pid())
            ngx.print(hc.status_page())
        }
    }
    # all the avaliable peers in json format:
    location = /swtcnodes {
        access_log off;
    
        default_type text/plain;
        content_by_lua_block {
            local hc = require "resty.upstream.healthcheck"
            local cjson = require "cjson"
            ngx.print(cjson.encode(hc.available_servers()))
        }
    }
}


