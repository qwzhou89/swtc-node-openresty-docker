# swtcnode.default.conf  
#

lua_package_path "/usr/local/openresty/ngx_lua_waf/?.lua;${prefix}/../lib/?.lua;;";
upstream swtc_ws_server {
    include /etc/nginx/conf.d/ws_servers; 
}
upstream swtc_wss_server {
    include /etc/nginx/conf.d/wss_servers;
}
upstream swtc_rpc_server {
    include /etc/nginx/conf.d/rpc_servers;
}

lua_shared_dict healthcheck 2m;
lua_shared_dict log_dict 2M;
lua_shared_dict limit 10m;

lua_socket_log_errors off;

init_by_lua_file  "/usr/local/openresty/ngx_lua_waf/init.lua";
access_by_lua_file "/usr/local/openresty/ngx_lua_waf/waf.lua";

resolver 223.5.5.5;
lua_max_running_timers 10;
lua_max_pending_timers 10;

init_worker_by_lua_block {
    local hc = require "resty.upstream.healthcheck"

    -- websocket command , white words ,black words for checking
    local ws_cmd_checks = {}
    ws_cmd_checks[1] = {[[{"id":1,"command":"server_info"}]], "(full|proposing)", "InsufficientNetworkMode"}
    ws_cmd_checks[2] = {[[{"id":2,"command":"account_info","account":"j4BdJBUCQN8JETufzagGZyqwxmTwJL42Vg"}]], nil, "InsufficientNetworkMode"}
    ws_cmd_checks[3] = {[[{"id":3,"command":"account_lines","account":"j4BdJBUCQN8JETufzagGZyqwxmTwJL42Vg"}]], nil, "InsufficientNetworkMode"}

    -- rpc command , white words ,black words for checking
    local rpc_cmd_checks = {}
    rpc_cmd_checks[1] = {[[{"method":"server_info","params":[{}]}]], "(full|proposing)", "InsufficientNetworkMode"}
    rpc_cmd_checks[2] = {[[{"method":"account_info","params":[{"account":"j4BdJBUCQN8JETufzagGZyqwxmTwJL42Vg"}]}]], nil, "InsufficientNetworkMode"}
    rpc_cmd_checks[3] = {[[{"method":"account_lines","params":[{"account":"j4BdJBUCQN8JETufzagGZyqwxmTwJL42Vg"}]}]], nil, "InsufficientNetworkMode"}

    -- spawn_checker options
    local checker_options = {
        shm = "healthcheck",  -- defined by "lua_shared_dict"
        interval = 3000,  -- run the check cycle every 3 sec
        timeout = 4000,   -- 4 sec is the timeout for network operations
        fall = 2,  -- # of successive failures before turning a peer down
        rise = 5,  -- # of successive successes before turning a peer up
        concurrency = 10,  -- concurrency level for test requests
    }

    -- ws server checker
    checker_options["upstream"] = "swtc_ws_server" -- defined by "upstream"
    checker_options["type"] = "ws"
    checker_options["ws_cmd_checks"] = ws_cmd_checks
    local ok, err = hc.spawn_checker(checker_options)
    if not ok then
        ngx.log(ngx.ERR, "failed to spawn ws server health checker: ", err)
        return
    end

    -- wss server checker
    checker_options["upstream"] = "swtc_wss_server" -- defined by "upstream"
    checker_options["type"] = "wss"
    checker_options["ws_cmd_checks"] = ws_cmd_checks
    local ok, err = hc.spawn_checker(checker_options)
    if not ok then
        ngx.log(ngx.ERR, "failed to spawn wss server health checker: ", err)
        return
    end
    
    -- rpc server checker
    checker_options["upstream"] = "swtc_rpc_server" -- defined by "upstream"
    checker_options["type"] = "rpc"
    checker_options["rpc_cmd_checks"] = rpc_cmd_checks
    local ok, err = hc.spawn_checker(checker_options)
    if not ok then
        ngx.log(ngx.ERR, "failed to spawn wss server health checker: ", err)
        return
    end
   
    -- # update the server list
    local function reset_server_list()
        local cjson = require "cjson"
        local http = require "resty.http"
        local httpc = http.new()

        local zabbix_rpc_addr = "https://stats.swtc.top/zabbix/api_jsonrpc.php"
        local params = {
            method = "POST",
            body = "",
            headers = {
                ["Content-Type"] = "application/json-rpc",
            },
            ssl_verify = false,
        }

        -- # login zabbix server and get authid
        params["body"] = [[{"jsonrpc":"2.0","method":"user.login","params":{"user":"swtcnode","password":"swtcnode@2019"},"id":1}]]
        local res, err = httpc:request_uri(zabbix_rpc_addr, params)
        if not res then
            ngx.log(ngx.ERR, "failed to request: " .. err)
            return
        end
        local authid = cjson.decode(res.body).result
        if not authid then
            ngx.log(ngx.ERR, "failed to login zabbix server with given user and password. ")
            return
        end

        -- # get ws service list from zabbix
        params["body"] = [=[{"jsonrpc":"2.0","method":"item.get","params":{"output":["name","lastvalue"],"search":{"key_":"skywelld.p2p.ws.services"}},"auth":"]=]
                .. authid .. [=[","id":2}]=]
        res, err = httpc:request_uri(zabbix_rpc_addr, params)                    
        if not res then
            ngx.log(ngx.ERR, "failed to request: " .. err)
            return
        end
        local results = cjson.decode(res.body).result
        if not results then
            ngx.log(ngx.ERR, "failed to get skywelld's ws service from zabbix system.")
            return
        end
        local servers = cjson.decode(results[1].lastvalue).wspeers
        if not servers then
            ngx.log(ngx.ERR, "ws service peers which got from zabbix system is null.")
            return
        end

        -- # write discoverd ws servers from zabbix to nginx's conf file
        local f, err = io.open("/etc/nginx/conf.d/ws_servers", "w+")
        if not f then
            ngx.log(ngx.ERR, "failed to open ws_servers file.")
            return
        end
        for _, server in pairs(servers) do
            f:write("    server  " .. string.sub(server, 6) .. ";\n") 
        end
        f:close ()

        -- # get rpc service list from zabbix
        params["body"] = [=[{"jsonrpc":"2.0","method":"item.get","params":{"output":["name","lastvalue"],"search":{"key_":"skywelld.p2p.rpc.services"}},"auth":"]=]
                .. authid .. [=[","id":3}]=]
        res, err = httpc:request_uri(zabbix_rpc_addr, params)                    
        if not res then
            ngx.log(ngx.ERR, "failed to request: " .. err)
            return
        end
        local results = cjson.decode(res.body).result
        if not results then
            ngx.log(ngx.ERR, "failed to get skywelld's rpc service from zabbix system.")
            return
        end
        local servers = cjson.decode(results[1].lastvalue).rpcpeers
        if not servers then
            ngx.log(ngx.ERR, "rpc service peers which got from zabbix system is null.")
            return
        end

        -- # write discoverd rpc servers from zabbix to nginx's conf file
        local f, err = io.open("/etc/nginx/conf.d/rpc_servers", "w+")
        if not f then
            ngx.log(ngx.ERR, "failed to open rpc_servers file.")
            return
        end
        for _, server in pairs(servers) do
            f:write("    server  " .. string.sub(server, 8) .. ";\n") 
        end
        f:close ()

    end

    -- reload the nginx by shell command
    local function restart_nginx()
        local shell = require "resty.shell"
        local f, err = io.open(ngx.config.prefix() .. "/logs/nginx.pid", "r")
        if not f then
            ngx.log(ngx.ERR, "failed to open nginx pid file.")
            return
        end
        local pid = f:read()
        f:close()
        local ok, stdout, stderr, reason, status =
            shell.run("kill -HUP " .. pid)
        if not ok then
            ngx.log(ngx.ERR, "failed to reload nginx by signal HUP.")
            return
        end
    end

    -- # update the ssl certificates list
    local function reget_ssl_certificate()
        -- # reload the nginx by shell command
        local shell = require "resty.shell"
        local ok, stdout, stderr, reason, status =
            shell.run("wget -O /etc/nginx/conf.d/fullchain.pem https://jccdex.cn/cert/fullchain.pem;" .. 
                        "wget -O /etc/nginx/conf.d/privkey.pem https://jccdex.cn/cert/privkey.pem ")
        if not ok then
            ngx.log(ngx.ERR, "failed to get ssl certificates from https://jccdex.cn/.")
            return
        end
    end

    local function reload(premature, from)
        if premature then
            return
        end
        local log_dict = ngx.shared.log_dict
        local newval, err = log_dict:incr(from, 1)
        if not newval and err == "not found" then
            log_dict:add(from, 0)
        end
        local atimes = log_dict:get(from)

        if from == "at" and atimes > 0 then
            return
        end
        reset_server_list()
        reget_ssl_certificate()
        restart_nginx()
    end 

    local process = require "ngx.process"
    if process.type() == "privileged agent" then
        local ok, err = ngx.timer.every(14400, reload, "every")
        if not ok then
            ngx.log(ngx.ERR, "failed to create the timer: ", err)
        end
        local ok, err = ngx.timer.at(3, reload, "at")
        if not ok then
            ngx.log(ngx.ERR, "failed to create the timer: ", err)
        end
    end
}
server {
    listen 5028 ssl;

    ssl_certificate /etc/nginx/conf.d/fullchain.pem;
    ssl_certificate_key /etc/nginx/conf.d/privkey.pem;

    ssl_session_timeout 5m;

    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers "HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES";
    ssl_prefer_server_ciphers on;

    location / {
        proxy_pass  https://swtc_wss_server;
        proxy_ssl_verify off;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    
        proxy_connect_timeout       60s;
        proxy_read_timeout          60s;
        proxy_send_timeout          60s;
    }
}
server {
    listen 5020;

    location / {
        proxy_pass  http://swtc_ws_server;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    
        proxy_connect_timeout       60s;
        proxy_read_timeout          60s;
        proxy_send_timeout          60s;
        log_by_lua_block {
            local log_dict = ngx.shared.log_dict
            local upstream_time = tonumber(ngx.var.upstream_response_time)
            if not upstream_time then
                log_dict:incr("us_time-sum-" .. ngx.var.upstream_addr, upstream_time, 0)
                log_dict:incr("us_time-nb-" .. ngx.var.upstream_addr, 1, 0)
            end
        }
    }
    # status page for all the peers:
    location = /status {
        access_log off;
        allow 127.0.0.1;
        allow 172.17.0.1;
        deny all;
    
        default_type text/plain;
        content_by_lua_block {
            local hc = require "resty.upstream.healthcheck"
            ngx.say("Nginx Worker PID: ", ngx.worker.pid())
            ngx.print(hc.status_page())
        }
    }
    # all the avaliable peers in json format:
    location = /swtcnodes {
        access_log off;
    
        default_type text/plain;
        content_by_lua_block {
            local hc = require "resty.upstream.healthcheck"
            local cjson = require "cjson"
            ngx.print(cjson.encode(hc.available_servers()))
        }
    }
    # access response time status
    location = /respstatus {
        default_type text/plain;
        content_by_lua_block {
            local log_dict = ngx.shared.log_dict
            local sum, nb

            local concat = table.concat
            local upstream = require "ngx.upstream"
            local get_servers = upstream.get_servers
            local get_upstreams = upstream.get_upstreams

            local us = get_upstreams()
            for _, u in ipairs(us) do
                ngx.say("upstream ", u, "(average upstream response time):")
                local srvs, err = get_servers(u)
                if not srvs then
                    ngx.say("failed to get servers in upstream ", u)
                else
                    for _, srv in ipairs(srvs) do
                        local first = true
                        sum = log_dict:get("us_time-sum-" .. srv["addr"])
                        nb = log_dict:get("us_time-nb-" .. srv["addr"])
                        if nb and sum then
                            ngx.say(srv["addr"], " : ", sum / nb, " (", nb, " reqs)")
                        else
                            ngx.say(srv["addr"], " : no data yet")
                        end
                    end
                end
            end
        }
    }
}

server {
    listen 5050 ssl;

    ssl_certificate /etc/nginx/conf.d/fullchain.pem;
    ssl_certificate_key /etc/nginx/conf.d/privkey.pem;

    ssl_session_timeout 5m;

    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers "HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES";
    ssl_prefer_server_ciphers on;

    location / {
        proxy_pass  http://swtc_rpc_server;
        proxy_http_version 1.1;
        log_by_lua_block {
            local log_dict = ngx.shared.log_dict
            local upstream_time = tonumber(ngx.var.upstream_response_time)
            if not upstream_time then
                log_dict:incr("us_time-sum-" .. ngx.var.upstream_addr, upstream_time, 0)
                log_dict:incr("us_time-nb-" .. ngx.var.upstream_addr, 1, 0)
            end
        }
   }
}

